//! # LDtk Json structure (version 0.5.1-beta)
//! <https://github.com/deepnight/ldtk/blob/master/JSON_DOC.md>
//! This was converted by hand, in an hour one evening,
//! from the above Markdown documentation, to Rust code,
//! using lots of regular expressions.

use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct Todo;

type Enum = Todo;
type Dynamic = Todo;
type Object = Todo;

type Float = f32;
type Int = i32;
type Bool = bool;
type Array<T> = Vec<T>;
/// LDtk Json root
#[derive(Serialize, Deserialize, Debug)]
pub struct Root {
    /// Project background color
    #[serde(rename = "bgColor")]
    pub bg_color: String,
    /// Default grid size for new layers
    #[serde(rename = "defaultGridSize")]
    pub default_grid_size: Int,
    /// Default X pivot (0 to 1) for new entities
    #[serde(rename = "defaultPivotX")]
    pub default_pivot_x: Float,
    /// Default Y pivot (0 to 1) for new entities
    #[serde(rename = "defaultPivotY")]
    pub default_pivot_y: Float,
    /// A structure containing all the definitions of this project
    #[serde(rename = "defs")]
    pub defs: Definitions,
    /// If TRUE, a Tiled compatible file will also be generated along with the LDtk JSON file (default is FALSE)
    #[serde(rename = "exportTiled")]
    pub export_tiled: Bool,
    /// File format version
    #[serde(rename = "jsonVersion")]
    pub json_version: String,
    /// Array of [Level]
    #[serde(rename = "levels")]
    pub levels: Array<Level>,
    /// If TRUE, the Json is partially minified (no indentation, nor line breaks, default is FALSE)
    #[serde(rename = "minifyJson")]
    pub minify_json: Bool,
}

/// Level
#[derive(Serialize, Deserialize, Debug)]
pub struct Level {
    /// Unique String identifier
    #[serde(rename = "identifier")]
    pub identifier: String,
    /// Array of [LayerInstance]
    #[serde(rename = "layerInstances")]
    pub layer_instances: Array<LayerInstance>,
    /// Height of the level in pixels
    #[serde(rename = "pxHei")]
    pub px_hei: Int,
    /// Width of the level in pixels
    #[serde(rename = "pxWid")]
    pub px_wid: Int,
    /// Unique Int identifier
    #[serde(rename = "uid")]
    pub uid: Int,
}

/// Layer instance
#[derive(Serialize, Deserialize, Debug)]
pub struct LayerInstance {
    /// Grid-based height
    #[serde(rename = "__cHei")]
    pub __cHei: Int,
    /// Grid-based width
    #[serde(rename = "__cWid")]
    pub __cWid: Int,
    /// Grid size
    #[serde(rename = "__gridSize")]
    pub __gridSize: Int,
    /// Unique String identifier
    #[serde(rename = "__identifier")]
    pub __identifier: String,
    /// (Added 0.4.0) Layer opacity as Float [0-1]
    #[serde(rename = "__opacity")]
    pub __opacity: Float,
    /// (Added 0.5.0) Total layer X pixel offset, including both instance and definition offsets.
    #[serde(rename = "__pxTotalOffsetX")]
    pub __pxTotalOffsetX: Int,
    /// (Added 0.5.0) Total layer Y pixel offset, including both instance and definition offsets.
    #[serde(rename = "__pxTotalOffsetY")]
    pub __pxTotalOffsetY: Int,
    /// Layer type (possible values: IntGrid, Entities, Tiles or AutoLayer)
    #[serde(rename = "__type")]
    pub __type: String,
    /// (Added 0.4.0) <sup>Only *Auto-layers*</sup> An array containing all tiles generated by Auto-layer rules. The array is already sorted in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).  		Note: if multiple tiles are stacked in the same cell as the result of different rules, all tiles behind opaque ones will be discarded.
    #[serde(rename = "autoLayerTiles")]
    pub autoLayerTiles: Array<TileInstance>,
    /// <sup>Only *Entity layers*</sup>
    #[serde(rename = "entityInstances")]
    pub entityInstances: Array<EntityInstance>,
    /// <sup>Only *Tile layers*</sup>
    #[serde(rename = "gridTiles")]
    pub gridTiles: Array<TileInstance>,
    /// <sup>Only *IntGrid layers*</sup> This object contains the following fields: <ul><li>**`coordId`** **(Int**) : *Coordinate ID in the layer grid*</li><li>**`v`** **(Int**) : *IntGrid value*</li></ul>
    #[serde(rename = "intGrid")]
    pub intGrid: Array<Object>,
    /// Reference the Layer definition UID
    #[serde(rename = "layerDefUid")]
    pub layerDefUid: Int,
    /// Reference to the UID of the level containing this layer instance
    #[serde(rename = "levelId")]
    pub levelId: Int,
    /// (Changed 0.5.0) X offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to the `LayerDef` optional offset)
    #[serde(rename = "pxOffsetX")]
    pub pxOffsetX: Int,
    /// (Changed 0.5.0) Y offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to the `LayerDef` optional offset)
    #[serde(rename = "pxOffsetY")]
    pub pxOffsetY: Int,
    /// <sup>Only *Auto-layers*</sup> Random seed used for Auto-Layers rendering
    #[serde(rename = "seed")]
    pub seed: Int,
}

/// Tile instance (Added 0.4.0)
#[derive(Serialize, Deserialize, Debug)]
pub struct TileInstance {
    /// Internal data used by the editor. 		For auto-layer tiles: `[ruleId, coordId, tileId]`. 		For tile-layer tiles: `[coordId, tileId]`.
    #[serde(rename = "d")]
    pub d: Array<Int>,
    /// "Flip bits", a 2-bits integer to represent the mirror transformations of the tile. 		 - Bit 0 = X flip 		 - Bit 1 = Y flip 		 Examples: f=0 (no flip), f=1 (X flip only), f=2 (Y flip only), f=3 (both flips)
    #[serde(rename = "f")]
    pub f: Int,
    /// (Changed 0.5.0) Pixel coordinates of the tile in the **layer** (`[x,y]` format). Don't forget optional layer offsets, if they exist!
    #[serde(rename = "px")]
    pub px: Array<Int>,
    /// Pixel coordinates of the tile in the **tileset** (`[x,y]` format)
    #[serde(rename = "src")]
    pub src: Array<Int>,
}

/// Entity instance
#[derive(Serialize, Deserialize, Debug)]
pub struct EntityInstance {
    /// (Changed 0.4.0) Grid-based coordinates (`[x,y]` format)
    #[serde(rename = "__grid")]
    pub __grid: Array<Int>,
    /// Unique String identifier
    #[serde(rename = "__identifier")]
    pub __identifier: String,
    /// (Can be `null`/`None`) (Added 0.4.0) Optional Tile used to display this entity (it could either be the default Entity tile, or some tile provided by a field value, like an Enum). This object contains the following fields: <ul><li>**`srcRect`** **(Array of Int**) : *An array of 4 Int values that refers to the tile in the tileset image: `[ x, y, width, height ]`*</li><li>**`tilesetUid`** **(Int**) : *Tileset ID*</li></ul>
    #[serde(rename = "__tile")]
    pub __tile: Option<Object>,
    /// Reference of the **Entity definition** UID
    #[serde(rename = "defUid")]
    pub defUid: Int,
    ///
    #[serde(rename = "fieldInstances")]
    pub fieldInstances: Array<FieldInstance>,
    /// (Changed 0.4.0) Pixel coordinates (`[x,y]` format). Don't forget optional layer offsets, if they exist!
    #[serde(rename = "px")]
    pub px: Array<Int>,
}

/// Field instance
#[derive(Serialize, Deserialize, Debug)]
pub struct FieldInstance {
    /// Unique String identifier
    #[serde(rename = "__identifier")]
    pub __identifier: String,
    /// Type of the field, such as Int, Float, Enum(enum_name), Bool, etc.
    #[serde(rename = "__type")]
    pub __type: String,
    /// (Anything) Actual value of the field instance. The value type may vary, depending on `__type` (Integer, Boolean, String etc.) 		It can also be an `Array` of various types.
    #[serde(rename = "__value")]
    pub __value: Dynamic,
    /// Reference of the **Field definition** UID
    #[serde(rename = "defUid")]
    pub defUid: Int,
}

/// Definitions
#[derive(Serialize, Deserialize, Debug)]
pub struct Definitions {
    ///
    #[serde(rename = "entities")]
    pub entities: Array<EntityDefinition>,
    ///
    #[serde(rename = "enums")]
    pub enums: Array<EnumDefinition>,
    /// Note: external enums are exactly the same as `enums`, except they 		have a `relPath` to point to an external source file.
    #[serde(rename = "externalEnums")]
    pub externalEnums: Array<EnumDefinition>,
    ///
    #[serde(rename = "layers")]
    pub layers: Array<LayerDefinition>,
    ///
    #[serde(rename = "tilesets")]
    pub tilesets: Array<TilesetDefinition>,
}

/// Layer definition
#[derive(Serialize, Deserialize, Debug)]
pub struct LayerDefinition {
    /// Type of the layer (*IntGrid, Entities, Tiles or AutoLayer*)
    #[serde(rename = "__type")]
    pub __type: String,
    /// <sup>Only *Auto-layers*</sup> Contains all the auto-layer rule definitions. This object contains the following fields: <ul><li>**`active`** **(Bool**)</li><li>**`collapsed`** **(Bool**)</li><li>**`name`** **(String**)</li><li>**`rules`** **(Array of [Auto-layer rule definition](#ldtk-AutoRuleDef)**)</li><li>**`uid`** **(Int**)</li></ul>
    #[serde(rename = "autoRuleGroups")]
    pub autoRuleGroups: Array<Object>,
    /// <sup>Only *Auto-layers*</sup>
    #[serde(rename = "autoSourceLayerDefUid")]
    pub autoSourceLayerDefUid: Int,
    /// <sup>Only *Auto-layers*</sup> Reference to the Tileset UID being used by this auto-layer rules
    #[serde(rename = "autoTilesetDefUid")]
    pub autoTilesetDefUid: Int,
    /// Opacity of the layer (0 to 1.0)
    #[serde(rename = "displayOpacity")]
    pub displayOpacity: Float,
    /// Width and height of the grid in pixels
    #[serde(rename = "gridSize")]
    pub gridSize: Int,
    /// Unique String identifier
    #[serde(rename = "identifier")]
    pub identifier: String,
    /// <sup>Only *IntGrid layer*</sup> This object contains the following fields: <ul><li>**`color`** **(String**) *Hex color "#rrggbb"*</li><li>**`identifier`** **(String**)</li></ul>
    #[serde(rename = "intGridValues")]
    pub intGridValues: Array<Object>,
    /// (Added 0.5.0) X offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance` optional offset)
    #[serde(rename = "pxOffsetX")]
    pub pxOffsetX: Int,
    /// (Added 0.5.0) Y offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance` optional offset)
    #[serde(rename = "pxOffsetY")]
    pub pxOffsetY: Int,
    /// <sup>Only *Tile layers*</sup> If the tiles are smaller or larger than the layer grid, the pivot value will be used to position the tile relatively its grid cell.
    #[serde(rename = "tilePivotX")]
    pub tilePivotX: Float,
    /// <sup>Only *Tile layers*</sup> If the tiles are smaller or larger than the layer grid, the pivot value will be used to position the tile relatively its grid cell.
    #[serde(rename = "tilePivotY")]
    pub tilePivotY: Float,
    /// <sup>Only *Tile layers*</sup> Reference to the Tileset UID being used by this tile layer
    #[serde(rename = "tilesetDefUid")]
    pub tilesetDefUid: Int,
    /// Unique Int identifier
    #[serde(rename = "uid")]
    pub uid: Int,
}

/// Auto-layer rule definition
#[derive(Serialize, Deserialize, Debug)]
pub struct AutoLayerRuleDefinition {
    /// If FALSE, the rule effect isn't applied, and no tiles are generated.
    #[serde(rename = "active")]
    pub active: Bool,
    /// When TRUE, the rule will prevent other rules to be applied in the same cell if it matches (TRUE by default).
    #[serde(rename = "breakOnMatch")]
    pub breakOnMatch: Bool,
    /// Chances for this rule to be applied (0 to 1)
    #[serde(rename = "chance")]
    pub chance: Float,
    /// If TRUE, enable checker mode
    #[serde(rename = "checker")]
    pub checker: Bool,
    /// If TRUE, allow rule to be matched by flipping its pattern horizontally
    #[serde(rename = "flipX")]
    pub flipX: Bool,
    /// If TRUE, allow rule to be matched by flipping its pattern vertically
    #[serde(rename = "flipY")]
    pub flipY: Bool,
    /// Rule pattern (size x size)
    #[serde(rename = "pattern")]
    pub pattern: Array<Int>,
    /// If TRUE, enable Perlin filtering to only apply rule on specific random area
    #[serde(rename = "perlinActive")]
    pub perlinActive: Bool,
    ///
    #[serde(rename = "perlinOctaves")]
    pub perlinOctaves: Float,
    ///
    #[serde(rename = "perlinScale")]
    pub perlinScale: Float,
    ///
    #[serde(rename = "perlinSeed")]
    pub perlinSeed: Float,
    /// <sup>Only *'Stamp' tile mode*</sup> X pivot of a tile stamp (0-1)
    #[serde(rename = "pivotX")]
    pub pivotX: Float,
    /// <sup>Only *'Stamp' tile mode*</sup> Y pivot of a tile stamp (0-1)
    #[serde(rename = "pivotY")]
    pub pivotY: Float,
    /// <![CDATA[Pattern width & height. Should only be 1,3,5 or 7.]]>
    #[serde(rename = "size")]
    pub size: Int,
    /// Array of all the tile IDs. They are used randomly or as stamps, based on `tileMode` value.
    #[serde(rename = "tileIds")]
    pub tileIds: Array<Int>,
    /// Defines how tileIds array is used
    #[serde(rename = "tileMode")]
    pub tileMode: Enum,
    /// Unique Int identifier
    #[serde(rename = "uid")]
    pub uid: Int,
    /// X cell coord modulo
    #[serde(rename = "xModulo")]
    pub xModulo: Int,
    /// Y cell coord modulo
    #[serde(rename = "yModulo")]
    pub yModulo: Int,
}

/// Entity definition
#[derive(Serialize, Deserialize, Debug)]
pub struct EntityDefinition {
    /// Base entity color
    #[serde(rename = "color")]
    pub color: String,
    /// Array of field definitions
    #[serde(rename = "fieldDefs")]
    pub fieldDefs: Array<FieldDefinition>,
    /// Pixel height
    #[serde(rename = "height")]
    pub height: Int,
    /// Unique String identifier
    #[serde(rename = "identifier")]
    pub identifier: String,
    /// Max instances per level
    #[serde(rename = "maxPerLevel")]
    pub maxPerLevel: Int,
    /// Pivot X coordinate (from 0 to 1.0)
    #[serde(rename = "pivotX")]
    pub pivotX: Float,
    /// Pivot Y coordinate (from 0 to 1.0)
    #[serde(rename = "pivotY")]
    pub pivotY: Float,
    /// Tile ID used for optional tile display
    #[serde(rename = "tileId")]
    pub tileId: Int,
    /// Tileset ID used for optional tile display
    #[serde(rename = "tilesetId")]
    pub tilesetId: Int,
    /// Unique Int identifier
    #[serde(rename = "uid")]
    pub uid: Int,
    /// Pixel width
    #[serde(rename = "width")]
    pub width: Int,
}

/// Field definition
/// Sorry this type has no documentation yet.
#[derive(Serialize, Deserialize, Debug)]
pub struct FieldDefinition {
    // TODO
}

/// Tileset definition
#[derive(Serialize, Deserialize, Debug)]
pub struct TilesetDefinition {
    /// Unique String identifier
    #[serde(rename = "identifier")]
    pub identifier: String,
    /// (Can be `null`/`None`) (Added 0.5.0) An array of all tiles that are fully opaque (ie. no transparent pixel). Used internally for optimizations.
    #[serde(rename = "opaqueTiles")]
    pub opaqueTiles: Option<Array<Int>>,
    /// Distance in pixels from image borders
    #[serde(rename = "padding")]
    pub padding: Int,
    /// Image width in pixels
    #[serde(rename = "pxHei")]
    pub pxHei: Int,
    /// Image width in pixels
    #[serde(rename = "pxWid")]
    pub pxWid: Int,
    /// Path to the source file, relative to the current project JSON file
    #[serde(rename = "relPath")]
    pub relPath: String,
    /// Space in pixels between all tiles
    #[serde(rename = "spacing")]
    pub spacing: Int,
    ///
    #[serde(rename = "tileGridSize")]
    pub tileGridSize: Int,
    /// Unique Intidentifier
    #[serde(rename = "uid")]
    pub uid: Int,
}

/// Enum definition
#[derive(Serialize, Deserialize, Debug)]
pub struct EnumDefinition {
    /// (Can be `null`/`None`) Relative path to the external file providing this Enum
    #[serde(rename = "externalRelPath")]
    pub externalRelPath: Option<String>,
    /// (Can be `null`/`None`) Tileset UID if provided
    #[serde(rename = "iconTilesetUid")]
    pub iconTilesetUid: Option<Int>,
    /// Unique String identifier
    #[serde(rename = "identifier")]
    pub identifier: String,
    /// Unique Int identifier
    #[serde(rename = "uid")]
    pub uid: Int,
    /// All possible enum values, with their optional Tile infos. This object contains the following fields: <ul><li>**`__tileSrcRect`** **(Array of Int**)  Added 0.4.0  : *An array of 4 Int values that refers to the tile in the tileset image: `[ x, y, width, height ]`*</li><li>**`id`** **(String**) : *Enum value*</li><li>**`tileId`** **(Int *(can be `null`)***) : *The optional ID of the tile*</li></ul>
    #[serde(rename = "values")]
    pub values: Array<Object>,
}
